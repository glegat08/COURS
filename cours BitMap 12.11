#include <iostream>
#include <vector>
#include <fstream>

using uint8 = unsigned char;

class BitMap
{
public:
	BitMap(const int& width = 0, const int& height = 0)
		: m_width(width)
		, m_height(height) 
	{
		updateInfoheader();
		updateFileheader();
	}

	~BitMap() = default;

	struct rgb
	{
		rgb(const uint8& r = 0, const uint8& g = 0, const uint8& b = 0)
		{
			pixel[0] = r;
			pixel[1] = g;
			pixel[2] = b;
		}
		uint8 pixel[3];
	};

	int getHeaderSize() const
	{
		return sizeof(m_fileheader) + sizeof(m_infoheader);
	}

	int getFileSize() const
	{
		return getHeaderSize() + getImageSize();
	}

	int getImageSize() const
	{
		const auto imageSize = m_width * m_height;
		return 3 * imageSize;
	}

	void setData(rgb* data, const int& size)
	{
		m_data.clear();
		m_data.resize(size);
		for (auto i = 0; i < size; ++i)
			m_data[i] = data[i];

		updateFileheader();
	}

	bool save(const std::string& fileName)
	{
		std::ofstream file(fileName, std::ios::binary);

		if (!file.is_open())
			return false;

		file.write(reinterpret_cast<char*>(&m_fileheader[0]), 14); // file header to write
		file.write(reinterpret_cast<char*>(&m_infoheader[0]), 40); // info header to write

		// write data
		const int rowSize = m_width * 3;
		const int paddingSize = (4 - (rowSize % 4)) % 4;
		char padding[3] = { 0, 0, 0 };

		for (int row = 0; row < m_height; ++row)
		{
			for (int col = 0; col < m_width; ++col)
			{
				const rgb& pixel = m_data[row * m_width + col];
				file.write(reinterpret_cast<const char*>(pixel.pixel), 3);
			}
			file.write(padding, paddingSize);
		}

		file.close();
		return true;
	}

private:

	int getPpm()
	{
		return 72 * 39.3701;
	}

	void updateFileheader()
	{
		static const int start = 2;
		const auto fileSize = getFileSize();
		for (auto i = 0; i < start + 4; ++i)
			m_fileheader[i] = static_cast<uint8>(fileSize >> (i - start) * 8);
	}

	void updateInfoheader()
	{
		static const int startWidth = 4;
		static const int startHeight = 8;
		static const int startimageSize = 20;
		static const int startPpm = startimageSize + 4;

		//width
		for (auto i = 0; i < startWidth + 4; ++i)
			m_infoheader[i] = static_cast<uint8>(m_width >> (i - startWidth) * 8);

		//height
		for (auto i = 0; i < startHeight + 4; ++i)
			m_infoheader[i] = static_cast<uint8>(m_height >> (i - startHeight) * 8);

		//image size
		for (auto i = 0; i < startimageSize + 4; ++i)
			m_infoheader[i] = static_cast<uint8>(getImageSize() >> (i - startimageSize) * 8);

		//resolution
		for (auto j = 0; j < 2; ++j)
		{
			const auto start = startPpm + 4 + j;
			for (auto i = 0; i < startPpm + 4; ++i)
				m_infoheader[i] = static_cast<uint8>(getPpm() >> (i - startPpm) * 8);
		}
	}

	uint8 m_fileheader[14] =
	{
		'B', 'M', // id
		0, 0, 0, 0, // size
		0, 0, // reserved
		0, 0, // reserved
		54, 0, 0, 0 // offset
	};

	uint8 m_infoheader[40] =
	{
		40, 0, 0, 0, // header size
		0, 0, 0, 0, // width
		0, 0, 0, 0, // height
		1, 0, // number of color plane
		24, 0, // bits per pixels
		0, 0, 0, 0, // compression default
		0, 0, 0, 0, // image size
		0, 0, 0, 0, // horizontal resolution
		0, 0, 0, 0, // vertical resolution
		0, 0, 0, 0, // number of colors
		0, 0, 0, 0 // number of important color
	};

	int m_width;
	int m_height;
	std::vector<rgb> m_data;
};

int main()
{
	BitMap bmp(2, 2);

	BitMap::rgb color[4] =
	{
		BitMap::rgb{255, 0, 0},
		BitMap::rgb{0, 255, 0},
		BitMap::rgb{0, 0, 255},
		BitMap::rgb{255, 0, 255},
	};

	bmp.setData(color, 4);

	bmp.save("C:\\Users\\guill\\Pictures\\MyBitmap.bmp");
}
